## 트리



### 트리

> 뒤집어 놓은 나무와 같은 모양

![img](https://i.imgur.com/6UeCp8t.png)

검정색 동그라미 하나하나를 **노드(node)**라하고, 노드와 노드를 잇는 선을 **엣지(edge)**라 한다.

**경로(Path)**란 엣지로 연결된 인접한 노드들로 이뤄진 시퀀스를 가리킨다. 경로의 길이는 엣지의 갯수를 의미한다.

트리의 **높이**는 루트노드에서 말단 노드에 이르는 가장 긴 경로의 엣지 수를 가리킨다. 트리의 특정 깊이를 가지는 노드의 집합을 **레벨**이라 한다.

**잎새노드(leaf node)**란 자식노드가 없는 노드를 말하고 internal node는 잎새노드를 제외한 노드를 나타낸다.(루트 노드또한 포함됨)

**루트노드(root node)**란 부모노드가 없는 노드를 말한다. 



트리의 속성 중 가장 중요한 것은 '루트 노드를 제외한 모든 노드는 단하나의 부모노드만을 가진다'는 것이다. 이 속성 때문에 트리는 다음과 같은 성질들을 만족한다.

- 임의의 노드에서 다른 노드로 가는 경로는 유일하다
  - 다음 예시에서는 경로가 유일하지 않기 때문에 트리가 아니다.
  - <img src="https://i.imgur.com/bWsiJtP.png" alt="img" style="zoom:50%;" />
- 회로(cycle)은 존재하지 않는다.
  - 사이클은 다음과 같은 형태를 말한다.
  - <img src="https://i.imgur.com/ySIf8Qf.png" alt="img" style="zoom:50%;" />
  - <img src="https://i.imgur.com/BUJI3k1.png" alt="img" style="zoom:50%;" />
- 모든 노드는 서로 연결되어 있다.
  - 다음은 연결되지 않은 노드가 존재하기 때문에 트리가 아니다
  - <img src="https://i.imgur.com/Bag6ue6.png" alt="img" style="zoom:50%;" />
- 엣지를 하나 자르면 트리가 두개로 분리된다.
- 엣지의 수는 노드의 수에서 1을 뺀 것과 같다.



### 이진트리

**이진트리**는 **자식 노드가 최대 두개**인 노드들로 구성된 트리를 말한다.

이진 트리에는 **정이진트리(full binary tree), 완전이진트리(complete binary tree), 균형이진트리(balanced binary tree)** 등이 있다.



**정이진트리**

정이진 트리는 모든 레벨에서 노드들이 꽉 채워진(= 잎새노드를 제외한 모든 노드가 자식노드르 2개 가지는) 이진트리를 말한다.

![img](https://i.imgur.com/edCd7lU.png)

정이진트리에서 레벨에 따른 노드의 숫자는 다음과 같다.

|   레벨    |      노드수       |
| :-------: | :---------------: |
|     0     |   2<sup>0</sup>   |
|     1     |   2<sup>1</sup>   |
|     2     |   2<sup>2</sup>   |
|     …     |         …         |
|     k     |   2<sup>k</sup>   |
| **total** | 2<sup>k+1</sup>−1 |

정이진트리에서는 노드의 총 갯수가 n일때 잎새노드의 수는 n/2를 올림한 숫자이다. 예를 들어 총 31개의 노드가 있을 때 잎새노드는 31/2를 올림한 16개를 가지고 있다.



**완전이진트리**

**완전이진트리**는 마지막 레벨을 제외한 모든 레벨에서 노드들이 꽉 채워진 이진트리를 말한다.

![img](https://i.imgur.com/mXssEqj.png)

정이진트리와 완전이진트리는 다음처럼 1차원 배열로도 표현이 기능하다.

![img](https://i.imgur.com/3sUWVY2.png)

이렇게 배열로 표현할 때 자식 노드들의 인덱스를 표현할 때는 아래와 같이 표현할 수 있다.

```
left_index = 2 * index + 1
right_index = 2 * index + 2
```



**균형이진트리**

모든 잎새노드의 깊이 차이가 많아야 1인 트리를 말한다.

![img](https://i.imgur.com/hPuxfES.png)



### 이진탐색트리 (Binary Search Tree)

> 이진탐색과 연결리스트를 결합한 자료구조의 일종

이진탐색의 효율적인 탐색을 유지하면서도, 빈번한 자료 입력과 삭제를 가능하게 고안됐다.

이진탐색의 경우 O(logn)의 속도로 탐색이 가능하지만,  자료의 입력, 삭제가 불가능하다. (이미 정렬된 수들로 탐색을 하기 때문에 비효율적으로 매번  정렬하면서 삽입하는 것이 불가능하다는 의미인 것 같다.)

연결리스트의 경우 자료 입력, 삭제에 필요한 시간복잡도는 O(1)로 효율적이지만 탐색 하는데에는 O(n)의 시간복잡도를 가진다. (삭제, 입력을 할 때 원소나 자리를 찾아가는데 시간이 들지만 배열에서와는 다르게 삭제 혹은 삽입뒤에 원소들의 자리를 옮겨줄 필요가 없다. 온전히 삽입/삭제에만 걸리는 시간복잡도를 의미한다.)



이진 탐색 트리는 다음과 같은 규칙으로 구성된다.

<img src="https://i.imgur.com/nCYjtI7.png" alt="img" style="zoom: 67%;" />

- 각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값을 가지는 노드들로 구성된다.
- 각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 큰 값을 지닌 노드들로 구성된다.
- 중복된 노드가 없어야 한다.
- 왼쪽 서브트리, 오른쪽 서브트리 또한 이진 탐색트리이다.

이진 탐색 트리를 순회할 때는 중위 순회(inorder)를 사용하면 모든 값들을 정렬된 순서대로 읽을 수 있다.



**삽입**

<img src="https://i.imgur.com/HBthwOc.png" alt="img" style="zoom:50%;" />

위와 같은 트리에 4를 추가한다고 할 때 7과 3사이에 4를 추가하면 4보다 큰 5가 4의 왼쪽 자식노드에 존재하게 된다. 이와 같이 트리의 중간에 새 데이터를 넣으면 하위트리의 트리 속성이 깨질 수도 있기 때문에 리프노드에만 데이터를 추가한다. 

이진탐색트리의 가장 왼쪽 잎새노드는 해당 트리의 최소값이 되고, 제일 오른쪽 잎새노드는 트리의 최대값이 된다.

이진탐색트리의 삽입의 시간복잡도는 삽입자체에 드는 O(1)을 무시하고, 삽입 위치를 찾아갈 때 높이가 h(루트에서 잎새노드 까지 이르는 엣지 수의 최대값)일때 O(h)가 된다.



**삭제**

삭제 연산을 할 때 이진탐색트리의 속성이 깨지지 않도록 해야한다. 

삭제를 할 때 세 가지 경우가 가능하다.



**1. 첫번째는 자식 노드가 없는 경우이다.**

이 케이스의 경우 노드를 그냥 삭제해도 된다.

<img src="https://i.imgur.com/d8sOy3z.png" alt="img" style="zoom:50%;" />

위 트리의 42와 같은 경우이다.



**2. 두 번째 경우는 자식 노드가 하나 있는 경우이다.**

이 경우, 해당 노드를 지우고, 해당 노드의 자식 노드와 부모 노드를 연결해주면 된다.

<img src="https://i.imgur.com/RqCRxO9.png" alt="img" style="zoom:67%;" />

위 트리에서 20을 삭제한다고 할 때 20의 서브 트리는 모두 30보다 작기 때문에 30과 20의 자식 노드 25를 연결 해줘도 이진탐색트리의 속성이 깨지지 않는다.



**3. 마지막 경우는 자식 노드가 두 개 있는 경우이다.**

<img src="https://i.imgur.com/yKzDYZu.png" alt="img" style="zoom:67%;" />

위의 트리에서 16 노드를 삭제한다고 할 때 13의 위치를 결정하기가 어렵다. 자식 노드가 두개일 때는 다른 방법을 고려해야 한다.

16의 왼쪽 서브트리에서 가장 큰 값은 13이고 이 노드를 predecessor라고 하고, 오른쪽 서브트리에서 가장 작은 값은 20이라하고 이 노드를 successor라고 한다.

이럴 때 predecessor 또는 successor를 삭제할 노드의 위치에 복사해두고 기존 predecessor 또는 successor노드를 삭제해주면 이진탐색트리의 속성을 유지하면서 삭제를 할 수 있다. 기존 노드를 삭제할 때도 나열한 경우의 수에 따라 삭제를 하면 이진탐색트리의 속성을 유지할 수 있다.

successor, predecessor 노드는 이진탐색 트리 구조상 하나의 자식노드를 가지거나 자식노드를 가지지 않는다.

<img src="https://i.imgur.com/po0R4GB.png" alt="img" style="zoom:67%;" />

successor를 기준으로 삭제 과정은 다음과 같다.

1. 삭제 대상 노드의 오른쪽 서브트리를 찾는다.
2. successor(1에서 찾은 서브트리의 최소값) 노드를 찾는다.
3. 2에서 찾은 successor의 값을 삭제 대상 노드에 복사한다.
4. successor 노드를 삭제한다.

삭제연산의 시간복잡도를 따질 때 3번째의 자식노드가 2개인 경우를 기준으로 계산해보면 트리의 높이가 h이고, 삭제대상 노드의 레벨이 d일 때, 1번 과정은 d번의 비교를 하고, successor를 찾는 2번 과정에서는 h-d번 비교 연산을 하게 된다. 따라서 O(d + h - d) 는 O(h)가 된다.

**한계점**

이진탐색트리의 탐색/삽입/삭제의 시간복잡도는 모두 O(h)이다.

트리의 높이 h에 의해 결정된다.

그런데 만약 트리의 모양이 다음과 같으면 트리의 연산이 노드 수에 비해 비효율적이게 된다.

<img src="https://i.imgur.com/XR4fujQ.png" alt="img" style="zoom: 67%;" />

이런 형태로 균형이 깨진 트리는 시간복잡도가 이진탐색의 O(logn)보다 오래 걸리게 된다. 이러한 문제점을 해결 하기위해 트리의 균형을 맞춘 AVL Tree가 있다.



**C++ 에서의 활용**

코딩테스트에서 코드를 작성하면서 이진검색 트리를 실제로 활용하게 되는 경우는 없고 라이브러리 중 이진탐색트리를 이용해서 구현된 라이브러리들을 사용할 수 있다.

- STL set은 값들을 이진 검색 트리로 저장하는 자료구조이고, 중복원소는 허용 하지 않는다.
- STL map은 (key, value)를 key에 대한 이진 검색 트리로 저장하는 자료구조이다. 중복 key는 허용하지 않는다.
- STL multiset은 값들을 이진 검색 트리로 저장하는 자료구조이고, 중복 원소가 허용된다.
- STL multimap은 (key,value)를 key에 대한 이진 검색 트리로 저장하는 자료구조이고, 중복 key가 허용된다.

참고 링크:

[https://ratsgo.github.io/data%20structure&algorithm/2017/10/21/tree/](
