# CH03 검색

## 03-1 검색 알고리즘

#### 배열 검색

1. 선형 검색: 무작위로 늘어놓은 데이터 모임에서 검색을 수행
2. 이진 검색: 일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색 수행
3. 해시법: 추가, 삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색 수행
   - 체인법: 같은 해시 값의 데이터를 선형 리스트로 연결하는 방법
   - 오픈 주소법: 데이터를 위한 해시 값이 충돌할 때 재해시하는 방법

**데이터 추가 비용?**

학생의 키를 학생의 번호를 통해 관리한다고 했을 때, 어떤 학생의 키를 검색하는 것은 굉장히 빠르다. 하지만, 중간에 새로운 학생의 키를 끼워넣어야 한다면, 뒤를 다 밀어야 하기 때문에 추가하기 위한 작업이 많다. 이런 것을 데이터를 추가하기 위한 비용이 많이 든다고 표현한다. 

## 03-2 선형 검색

요소가 직선 모양으로 늘어선 배열에서 원하는 키 값을 갖는 요소를 만날 때까지 맨 앞부터 순서대로 요소를 검색하는 방법. linear search.

```java
static int seqSearch(int[] a, int n, int key) {
  for (int i = 0; i < n; i++)
    if (a[i] == key)
      return i;
  return -1;
}
```

#### 보초법

위의 형태로 작성된 코드는 한번의 루프를 돌 때마다 두 번의 비교가 진행된다. i에 대한 비교, a[i]와 key의 비교. 만약 워스트 케이스여서 검색하고자 하는 값이 배열에 없다면 바깥의 for문을 위해 (n + 1)번을 비교하고, 안에 있는 비교도 n번을 진행하게 된다. 이렇게 하는 대신, 배열의 끝에 찾고자 하는 값을 하나 추가하여 선형 검색을 하면 (n + 2)번의 비교로 원하는 결과를 도출할 수 있다. 

```java
while(a[i] != key)
  i++;
return i == n ? -1 : i;
```

## 03-3 이진 검색

이진 검색은 데이터가 키 값으로 이미 정렬되어 있어야 한다. 선형 검색보다 조금 더 빠르게 검색할 수 있다. 

검색하는 범위는 매번 반으로 줄어든다. 최소값, 최대값, 중간값을 정해두고 찾으려는 값이 중간값보다 작은지 큰지를 비교한다. 중간값보다 크다면 최소값은 중간값 다음으로 인덱스를 옮기고, 중간값보다 작다면 최대값을 중간값보다 하나의 앞으로 옮겨서 다시 반복문을 돌게 된다. 

이진 검색의 시간 복잡도는 보통 log n이다. 

```java
public class BinSearch {
	// 요수 수가 n인 배열 a에서 key와 같은 요소를 이진 검색합니다. 
	static int binSearch(int[] a, int n, int key) {
		int pl = 0;
		int pr = n - 1;
		
		do {
			int pc = (pl + pr) / 2;
			if (a[pc] == key)
				return pc;
			else if (a[pc] < key)
				pl = pc + 1;
			else
				pr = pc - 1;
		} while (pl <= pr);
		
		return -1;
	}
}
```

#### 복잡도

알고리즘의 성능을 객관적으로 평가하는 기준. complexity. 

1. 시간 복잡도: 실행에 필요한 시간을 평가한 것
2. 공간 복잡도: 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것. 

선형 검색의 경우 n에 비례하여 1번이라고 볼 수 있기 때문에 O(n)의 시간 복잡도를 가진다. 

2개 이상의 복잡도로 구성된 알고리즘의 전체 복잡도는 차원이 더 높은 쪽의 복잡도를 우선시한다. 즉, 전체 복잡도는 차원이 가장 높은 복잡도를 선택하는 것이다. 

**복잡도와 증가율**

1 > log n > n > n log n > n^2 > n^3 > n^k > 2^n

#### 연습문제 5: key 중복 시 가장 앞의 인덱스 추출

```java
public class BinSearchX {
	// 요수 수가 n인 배열 a에서 key와 같은 요소를 이진 검색합니다. 
	static int binSearchX(int[] a, int n, int key) {
		int pl = 0;
		int pr = n - 1;
		
		do {
			int pc = (pl + pr) / 2;
			if (a[pc] == key) {
				while (a[pc - 1] == key)
					pc--;
				return pc;
			}
			else if (a[pc] < key)
				pl = pc + 1;
			else
				pr = pc - 1;
		} while (pl <= pr);
		
		return -1;
	}
	
	public static void main(String[] args) {
		int[] a = {1, 2, 5, 7, 7, 7, 7, 8, 8, 9, 9};
		
		System.out.println(binSearchX(a, 11, 7));
	}
}
```

#### 이진 검색 라이브러리

java.util.Arrays 클래스에서 binarySearch라는 메서드를 제공한다. 

#### 클래스 메서드와 인스턴스 메서드

인스턴스 메서드는 static없이 선언된 메서드, 클래스는 static을 붙여 선언한 메서드이다. 클래스 자체에 대한 공통된 필드나 메서드의 경우 static을 붙여서 선언하면 어디서든 접근을 할 수 있다. 인스턴에만 한정되는 필드와 메서드는 각 인스턴스마다 다른 결과를 도출하게 된다. 













