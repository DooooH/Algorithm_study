## 해시(Hash)

>삽입, 삭제, 검색 모두 O(1). Collision이 자주 일어날 수록 시간복잡도는 나빠진다.



#### N명의 사람에 대해 각 사람이 가진 16자리의 카드 번호 데이터가 있다고 할 때, 각 카드 번호에 대응 되는 사람을 어떻게 빠르게 찾을 것인가?

|          0          |          1          |          2          |          3          |          4          |          5          |          6          |          7          |          8          |          9          |
| :-----------------: | :-----------------: | :-----------------: | :-----------------: | :-----------------: | :-----------------: | :-----------------: | :-----------------: | :-----------------: | :-----------------: |
| 1351 9672 3313 4752 | 9811 5626 9133 4492 | 6166 0412 3339 4491 | 4611 9004 3383 2494 | 9748 1584 9813 5678 | 1237 9223 3893 8186 | 9571 9004 7483 5194 | 4941 9004 3383 4894 | 4411 9004 3523 4121 | 0098 7890 3753 4752 |
|         Kim         |         Lee         |        Choi         |         Son         |        Park         |         Ma          |         Bae         |        Wang         |        Cheon        |         Ko          |

특정 16자리의 카드번호가 주어졌을 때, 해당 카드번호에 대응 되는 사람을 **처음부터 끝까지 순차적으로 비교해나가면 O(N)**의 시간복잡도로 찾을 수 있을 것이다.

이때, **만약 카드 번호가 4자리라면** Count Sort를 하는 것 처럼 **긴 배열을 만들어서 O(1)에 탐색이 가능한 테이블**을 만들수 도 있을 것이다. 그런데 **카드 번호가 16자리일때**는 10<sup>16</sup>개의 int배열을 만드려면 **40PB(4 * 10<sup>6</sup>GB)의 공간이 필요하므로 현실적으로 불가능하다.**

그렇다면 그냥 **앞 4자리만 인덱스로 사용해서 배열**을 만들면 되지 않을까? 이렇게 16자리의 카드 번호를 4자리의 번호에 대응하도록 하는것 처럼 **임의의 길이를 고정된 길이의 데이터로 대응하게 하는 것이 해시함수**이다.

이러한 해시함수는 카드번호의 가능한 갯수 10<sup>16</sup>에서 10<sup>4</sup>개로 줄인 것 처럼 **정의역을 줄이려고 하기 때문에 충돌이 발생할 수 밖에 없다.** 이런 해시함수의 특성에서 나온 문제점인 **충돌(Collision)**을 해결하기 위한 방법을 Collision Resolution이라 하며 두가지의 방법이 있다.

- Open Addressing
  - 충돌이 발생할 경우 원소를 저장하는 **인덱스를 바꾸어** 충돌을 회피
    - Linear Probing
      - 한칸씩
    - Quadratic Probing
      - 제곱으로
    - Double Hashing
      - 한번 더 해싱
- Chaining
  - 각 인덱스가 **원소 1개만을 담는 것이 아니라, Linked List구조로 여러 원소를 담는 방식**

참고링크 : https://blog.encrypted.gg/856?category=773649
